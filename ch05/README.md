# Chapter 05 -- 物件封裝 #

## 學習目標 ##

* 了解封裝概念與實現
* 定義類別、建構式與方法
* 使用方法重載與不定長度引述
* 了解 static 成員

## 小節 ##

* [5.1 何謂封裝?](#51-何謂封裝)
* [5.2 類別語法細節](#52-類別語法細節)
* [5.3 重點複習](#53-重點複習)

## 5.1 何謂封裝? ##

### 5.1.1 封裝物件初始流程 ##

* 建構式 (Constructor)
  * 使用建構式，改善透過 . 運算子存取物件的重複流程。
  * 建構式式與類別名稱同名的方法 (Method)。
  * 使用建構式語法，實現物件初始化流程的封裝。

### 5.1.2 封裝物件操作流程 ##

* 定義物件的方法，封裝操作的流程。
* 在 Java 命名慣例中，方法名稱首字是小寫。

### 5.1.3 封裝物件內部資料 ##

* 使用 private 關鍵字，不讓使用者直接存取私有資料
* 在 Java 命名規範中，取值方法的名稱形式是固定的，也就是以 get 開頭，之後接上首字大寫的單字。
* 封裝了類別私有資料，讓使用者無法直接存取，而必須透過提供的操作方法，經過定義的流程才有可能存取私有資料。

## 5.2 類別語法細節 ##

### 5.2.1 public 權限修飾 ###

* 如果沒有宣告權限修飾的成員，只有在相同套件的類別程式碼中，才可以直接存取，也就是"套件範圍權限"。

### 5.2.2 關於建構式 ###

* 預設建構式 (Default constructor)
  * 如果定義類別時，沒有撰寫任何建構式，編譯器會自動加入一個無參數、內容為空的建構式。
  * 無參數、沒有內容的建構式，稱 Nullary 建構式。
  * 只有編譯器自動加入的建構式，才能稱為預設建構式。

### 5.2.3 建構式與方法重載 ###

* 可以定義多個建構式，只要參數型態或個數不同，就稱為重載 (Overload) 建構式。
* 定義方法時，也可以進行重載，以便為類似功能的方法提供統一名稱，然而編譯時期，會根據參數型態或個數，決定要呼叫的對應方法。
* 方法重載讓開發者不用苦惱於方法名稱的設計，使用一致的名稱呼叫類似功能的方法即可。
* 返回值型態不可作為方法重載的依據。
* 在 JDK5 以後，使用方法重載時，要注意自動裝箱、拆箱問題。

### 5.2.4 使用 this ###

* this 可以代表"這個物件"的參考名稱。
* this() 代表呼叫另一個建構式，至於呼叫哪個建構式，就看呼叫 this() 時給的蔭樹型態與個數而定。
* this() 呼叫只能在建構式的第一行。
* final 關鍵字
  * 修飾變量
    * final 成員變量表示常量，賦值一次後，只能讀，不能寫。
  * 修飾方法
    * final 方法不能被子類方法覆蓋，但可以被繼承。
  * 修飾類別
    * final 類別不能被繼承，沒有子類，final 類別中的所有方法都是 final 方法。
  * 與 const 類似，但 const 不常用
  * 如果物件資料成員被宣告為 final，但沒有明確使用 = 指定值，表示延遲物件成員值的指定。在後續的建構式執行流程中，一定要有對該資料成員指定值的動作。

### 5.2.5 static 成員 ###

* 被宣告為 static 的成員，
  * 不會讓個別實力擁有，而是屬於類別。
  * 是將類別名稱作為名稱空間。
* in, out 都是 System 擁有的 static 成員
  * System.in, System.out
* 在 static 方法或區塊中，不能出現 this 關鍵字。
* static 方法中，不能用非 static 的資料成員，也不能用非 static 的方法
* 在 JDK5 以後，新增了 import static 語法，可以在使用靜態成員時，少打幾個字。

### 5.2.6 不定長度引數 ###

* JDK5 以後支援不定長度引數 (Variable-length Argument)
* 不定長度引數是編譯器蜜糖，實際上展開為陣列
* 使用不定長度引數十，方法上宣告的不定長度參數，必須是參數列最後一個
* 使用兩個以上不定長度引數也是不合法的

### 5.2.7 內部類別 ###

* 類別內部中再定義類別，稱為內部類別 (Inner class)

### 5.2.8 傳值呼叫 ###

* Java 中，只有傳值呼叫 (Call by value, pass by value)

## 5.3 重點複習 ##

* 建構式實現物件初始化流程的封裝。
* 方法封裝了操作物件的流程。
* Java 中，可以使用 private 封裝物件私有資料成員。
* 封裝的目的主要就是隱藏物件細節。
* 如果沒有宣告權限修飾的成員，只有在相同套件的獵別程式碼中，才可以直接存取。
* 被宣告為 static 的成員，不會讓個別物件擁有，而使屬於類別。
